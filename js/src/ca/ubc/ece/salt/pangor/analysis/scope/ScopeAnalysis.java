package ca.ubc.ece.salt.pangor.analysis.scope;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.mozilla.javascript.ast.AstNode;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.ast.ScriptNode;

import ca.ubc.ece.salt.gumtree.ast.ClassifiedASTNode;
import ca.ubc.ece.salt.pangor.analysis.Alert;
import ca.ubc.ece.salt.pangor.analysis.Analysis;
import ca.ubc.ece.salt.pangor.analysis.DataSet;
import ca.ubc.ece.salt.pangor.analysis.flow.FunctionTreeVisitor;
import ca.ubc.ece.salt.pangor.batch.AnalysisMetaInformation;
import ca.ubc.ece.salt.pangor.cfg.CFG;
import ca.ubc.ece.salt.pangor.classify.alert.ClassifierAlert;

/**
 * Builds a scope tree for the source and destination ASTs. This is used
 * as the basis for performing flow analysis, but can also be used stand-alone
 * if only scope is needed.
 *
 * NOTE: This class only works with the Mozilla Rhino AST.
 *
 * @param <U> The type of alert the data set stores.
 * @param <T> The type of data set that stores the analysis results.
 */
public class ScopeAnalysis<U extends Alert, T extends DataSet<U>> extends Analysis<U, T> {

	/**
	 * The repair alerts generated by the analysis.
	 */
	private Map<AstNode, List<ClassifierAlert>> alerts;

	/**
	 * Used to generate unique IDs for anonymous functions.
	 */
	private int anonymousIDGen;

	/**
	 * Keep track of the identity of the current CFG being analyzed (useful
	 * for the analysis functions of analyses that extend ScopeAnalysis.
	 */
	private String currentCFGIdentity;

	protected List<CFG> srcCFGs;
	protected List<CFG> dstCFGs;

	protected Scope srcScope;
	protected Scope dstScope;

	/** Maps function nodes to their scopes. */
	protected Map<ScriptNode, Scope> srcScopeMap;

	/** Maps function nodes to their scopes. */
	protected Map<ScriptNode, Scope> dstScopeMap;

	public ScopeAnalysis(T dataSet, AnalysisMetaInformation ami) {
		super(dataSet, ami);
		this.alerts = new HashMap<AstNode, List<ClassifierAlert>>();
		this.anonymousIDGen = 0;
		this.currentCFGIdentity = null;
	}

	/**
	 * @return the source scope tree.
	 */
	public Scope getSrcScope() {
		return this.srcScope;
	}

	/**
	 * @return the destination scope tree.
	 */
	public Scope getDstScope() {
		return this.dstScope;
	}

	/**
	 * @param node the script or function
	 * @return the source scope tree.
	 */
	public Scope getSrcScope(ScriptNode node) {
		return this.srcScopeMap.get(node);
	}

	/**
	 * @param node the script or function
	 * @return the destination scope tree.
	 */
	public Scope getDstScope(ScriptNode node) {
		return this.dstScopeMap.get(node);
	}

	@Override
	public void analyze(ClassifiedASTNode root, List<CFG> cfgs) throws Exception {

		/* Check we are working with the correct AST type. */
		if(!(root instanceof AstRoot)) throw new IllegalArgumentException("The AST must be parsed from Apache Rhino.");
		AstRoot script = (AstRoot) root;

		this.dstScopeMap = new HashMap<ScriptNode, Scope>();
		this.dstCFGs = cfgs;
		this.dstScope = this.buildScopeTree(script, null, this.dstScopeMap, null);

	}

	@Override
	public void analyze(ClassifiedASTNode srcRoot, List<CFG> srcCFGs, ClassifiedASTNode dstRoot,
			List<CFG> dstCFGs) throws Exception {

		/* Check we are working with the correct AST type. */
		if(!(srcRoot instanceof AstRoot) || !(dstRoot instanceof AstRoot)) throw new IllegalArgumentException("The AST must be parsed from Apache Rhino.");
		AstRoot srcScript = (AstRoot) srcRoot;
		AstRoot dstScript = (AstRoot) dstRoot;

		this.srcScopeMap = new HashMap<ScriptNode, Scope>();
		this.dstScopeMap = new HashMap<ScriptNode, Scope>();
		this.srcCFGs = srcCFGs;
		this.dstCFGs = dstCFGs;
		this.srcScope = this.buildScopeTree(srcScript, null, this.srcScopeMap, null);
		this.dstScope = this.buildScopeTree(dstScript, null, this.dstScopeMap, null);

	}

	/**
	 * Builds the scope tree.
	 * @return the root of the scope tree.
	 * @throws Exception
	 */
	private Scope buildScopeTree(ScriptNode function, Scope parent, Map<ScriptNode, Scope> scopeMap, String parentIdentity) throws Exception {

		/* Create a unique identity for the function. */
		String identity = "Script";
		if(parentIdentity != null) {
			assert(function instanceof FunctionNode);
			String functionName = this.getFunctionName((FunctionNode) function);
			identity = parentIdentity + "." + functionName;
		}

        /* Create a new scope for this script or function and add it to the
         * scope tree. */
		Scope scope = new Scope(parent, function, identity);
		if(parent != null) parent.children.add(scope);
		ScopeVisitor.getLocalScope(scope);

		/* Put the scope in the scope map. */
		scopeMap.put(function, scope);

        /* Analyze the methods of the function. */
        List<FunctionNode> methods = FunctionTreeVisitor.getFunctions(function);
        for(FunctionNode method : methods) {
        	buildScopeTree(method, scope, scopeMap, identity);
        }

        return scope;

	}

	/**
	 * Registers an alert to be reported to the user.
	 * @param alert
	 */
	protected void registerAlert(AstNode node, ClassifierAlert alert) {
		List<ClassifierAlert> alerts = this.alerts.get(node);

		if(alerts == null) {
			alerts = new LinkedList<ClassifierAlert>();
			this.alerts.put(node, alerts);
		}

		alerts.add(alert);
	}

	/**
	 * @return the identity of the current CFG being analyzed (useful for the
	 * analyses that extend this to correlate the results they produce to the
	 * function they are analyzing).
	 */
	protected String getCurrentCFGIdentity() {
		return this.currentCFGIdentity;
	}

	/**
	 * Sets the identity of the current CFG being analyzed (useful for the
	 * analyses that extend this to correlate the results they produce to the
	 * function they are analyzing).
	 * @param currentCFGIdentity
	 */
	protected void setCurrentCFGIdentity(String currentCFGIdentity) {
		this.currentCFGIdentity = currentCFGIdentity;
	}

	/**
	 * @param function The function to generate a name for.
	 * @return the function name (if is a named function) or a unique ID if it
	 * 		   is an anonymous function.
	 */
	private String getFunctionName(FunctionNode function) {
		String functionName = function.getName();
		if(functionName.isEmpty()) {
			functionName = "~A" + this.getAnonymousFunctionID() + "~";
		}
		return functionName;
	}

	/**
	 * @return A unique ID for anonymous functions.
	 */
	private int getAnonymousFunctionID() {
		this.anonymousIDGen = this.anonymousIDGen + 1;
		return this.anonymousIDGen;
	}

}
