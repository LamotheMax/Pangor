require "csv"

INPUT_FILE = "../output/remote/dataset.csv"
SUPPLEMENTARY_FOLDER = '../output/remote/supplementary/'

class Alert
  attr_accessor :id, :project, :function_name, :type, :subtype, 
    :short_description, :long_description, :inspection_result,
    :original_row

  def initialize(row)
    @original_row = row

    @id = row[0]
    @project = row[1]
    @function_name = row[7]
    @type = row[8]
    @subtype = row[9]
    @short_description = row[10]
    @long_description = row[11]

    # Check if the file we are reading has already inspection results
    if (%w{y n ?}.include?(row[12]))
      @inspection_result = row[12]
    else
      @inspection_result = ""
    end
  end

  def to_s
    "ID: #{@id} \nPROJECT: #{@project} \nTYPE: #{@type} \nSUBTYPE: #{@subtype}" + 
      "\nFUNCTION: #{@function_name} \nSHORT: #{@short_description} \nLONG: #{long_description} \n\n== INSPECTION_RESULT: #{inspection_result}"
  end

  def to_array
    if (@original_row.size == 12)
      # We are inspecting dataset.csv from classifier, 
      # which does not have yet a column for inspection results, so we create it

      return @original_row << @inspection_result  
    else
      # We are inspecting a file generated by this script,
      # which has a column for inspection results, so we update it

      @original_row[-1] = @inspection_result
      return @original_row
    end
    
  end
end

class DiffViewer
  TOOL = 'meld'

  def self.open(alert)
    src = File.join(SUPPLEMENTARY_FOLDER, "#{alert.id}_src.js")
    dst = File.join(SUPPLEMENTARY_FOLDER, "#{alert.id}_dst.js")

    Process.spawn("#{TOOL} #{src} #{dst}")
  end

  def self.kill(pid)
    Process.kill('TERM', pid)
  end
end


# Parse csv file
alerts = []

skip_to_next_empty = false

current_row = 1
total_rows = File.open(INPUT_FILE).count


# First we create array with all alerts
CSV.foreach(INPUT_FILE) do |row|
  alert = Alert.new(row)
  alerts << alert
end

# Shuffle the alerts and sort by inspection results
alerts = alerts.shuffle.sort_by{|a| a.inspection_result}.reverse

# Then we start the inspection
for alert in alerts 

  # If we are looking for next empty
  if skip_to_next_empty

    # If this alert is empty, stop it here
    if (alert.inspection_result.nil? || alert.inspection_result.empty?)
      skip_to_next_empty = false
    else
      current_row += 1
      next
    end
  end

  # Open diff
  pid = DiffViewer.open(alert)

  # Read input
  puts "\n=== Alert inspection (#{current_row} / #{total_rows}) ==="
  puts alert
  puts "\n(y) for YES, (n) for NO,"
  puts "(s) or (anything) to SKIP to next alert"
  puts "(ss) to SKIP-SKIP to next inespected alert"
  puts "(q) for QUIT"
  input = gets.chomp

  # Close diff
  DiffViewer.kill(pid)

  # Parse input
  case input
  when 'y', 'n'
    alert.inspection_result = input
  when 'q'
    break
  when 'ss'
    skip_to_next_empty = true
    next
  end 
  
  # Increment counter, just to show to user
  current_row += 1
end

puts "==> Saving file"

# Save alerts to file
CSV.open(INPUT_FILE, "w") do |csv|
  for alert in alerts
    csv << alert.to_array
  end
end