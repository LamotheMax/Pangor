package ca.ubc.ece.salt.sdjsb.analysis.flow;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.mozilla.javascript.ast.AstNode;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.ScriptNode;

import ca.ubc.ece.salt.sdjsb.alert.Alert;
import ca.ubc.ece.salt.sdjsb.analysis.scope.Scope;
import ca.ubc.ece.salt.sdjsb.analysis.scope.ScopeAnalysis;
import ca.ubc.ece.salt.sdjsb.cfg.CFG;
import ca.ubc.ece.salt.sdjsb.cfg.CFGEdge;
import ca.ubc.ece.salt.sdjsb.cfg.CFGNode;

/**
 * Performs a change-sensitive, intra-procedural analysis.
 * 
 * This framework provides the analysis framework and the current scope.
 * 
 * Loops are executed once.
 * 
 * @param <LE> The lattice element type that stores the analysis information.
 */
public abstract class FlowAnalysis<LE extends AbstractLatticeElement> extends ScopeAnalysis {

	/**
	 * The repair alerts generated by the analysis.
	 */
	private Map<AstNode, List<Alert>> alerts;

	public FlowAnalysis() { }
	
	/**
	 * Performs a flow analysis.
	 * 
	 * For JavaScript, we need to store the function-hierarchy so we can analyze
	 * them in-order and build the scope for each function.is of the script.
	 * 
	 * @param root The root AST node for the script.
	 * @param cfgs The control flow graphs for the functions (and script).
	 * @throws Exception
	 */
	@Override
	public void analyze(AstRoot root, List<CFG> cfgs) throws Exception {
		
		/* Build the scope. */
		super.analyze(root, cfgs);

		/* Analyze the file. */
		this.alerts = new HashMap<AstNode, List<Alert>>();
		this.analyze(this.dstScope, this.dstCFGs);

	}

	/**
	 * Performs a flow analysis.
	 * 
	 * For JavaScript, we need to store the function-hierarchy so we can analyze
	 * them in-order and build the scope for each function.is of the script.
	 * 
	 * @param dstRoot The root AST node for the script.
	 * @param dstCFGs The control flow graphs for the functions (and script).
	 * @throws Exception
	 */
	@Override
	public void analyze(AstRoot srcRoot, List<CFG> srcCFGs, AstRoot dstRoot, List<CFG> dstCFGs) throws Exception {
		
		/* Build the scope. */
		super.analyze(srcRoot, srcCFGs, dstRoot, dstCFGs);

		/* Analyze the destination file. */
		this.alerts = new HashMap<AstNode, List<Alert>>();
		this.analyze(this.dstScope, this.dstCFGs);
		this.analyze(this.srcScope, this.srcCFGs);

	}

	/**
	 * @return a list of the alerts from this analysis.
	 */
	@Override
	public Set<Alert> getAlerts() {
		Set<Alert> alerts = new HashSet<Alert>();
		for(AstNode node : this.alerts.keySet()){
			alerts.addAll(this.alerts.get(node));
		}
		return alerts;
	}

	/**
	 * @return a map of the results from this analysis.
	 */
	public Map<AstNode, List<Alert>> getResults() {
		return this.alerts;
	}
	
	/**
	 * Perform a path-sensitive analysis.
	 * 
	 * As we discover variable declarations, we add them to the scope.
	 * 
	 * @param cfg the control flow graph for the function or script we are analyzing.
	 * @param scopeStack the scope for the function.
	 */
	abstract protected void analyze(CFG cfg, Scope scope);

	/**
	 * @param function The function under analysis.
	 * @return an initialized lattice element for the function.
	 */
	public abstract LE entryValue(ScriptNode function);

	/**
	 * Transfer the lattice element over the CFGEdge.
	 * @param edge The edge to transfer over.
	 */
	public abstract void transfer(CFGEdge edge, LE sourceLE, Scope scope);

	/**
	 * Transfer the lattice element over the CFGNode.
	 * @param node The node to transfer over.
	 */
	public abstract void transfer(CFGNode node, LE sourceLE, Scope scope);
	
	/**
	 * @param le The lattice element to copy.
	 * @return a deep copy of the lattice element.
	 */
	public abstract LE copy(LE le);

	/**
	 * Registers an alert to be reported to the user.
	 * @param alert
	 */
	protected void registerAlert(AstNode node, Alert alert) {
		List<Alert> alerts = this.alerts.get(node);
		
		if(alerts == null) {
			alerts = new LinkedList<Alert>();
			this.alerts.put(node, alerts);
		}
		
		alerts.add(alert);
	}

	/**
	 * Discovers functions and sends them to be analyzed. Keeps track of
	 * function scopes to be passed to sub-functions.
	 * @throws Exception
	 */
	private void analyze(Scope scope, List<CFG> cfgs) throws Exception {
		
        /* Analyze node. */
        
        CFG cfg = this.getFunctionCFG(scope.scope, cfgs);
        if(cfg == null) throw new Exception("CFG not found for function.");
        this.setCurrentCFGIdentity(scope.identity);
        this.analyze(cfg, scope);

        /* Analyze the methods of the function. */

        for(Scope childScope : scope.children){
        	analyze(childScope, cfgs);
        }
        
	}
	
	/**
	 * Find the CFG for the script or function.
	 * @param node a AstRoot or FunctionNode
	 * @return the CFG for the script or function.
	 */
	private CFG getFunctionCFG(ScriptNode node, List<CFG> cfgs) {
		
		for(CFG cfg : cfgs) {
			if(cfg.getEntryNode().getStatement() == node) return cfg;
		}
		
		return null;
		
	}
	
}
