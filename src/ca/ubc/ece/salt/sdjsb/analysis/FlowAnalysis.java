package ca.ubc.ece.salt.sdjsb.analysis;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.FunctionNode;
import org.mozilla.javascript.ast.Name;
import org.mozilla.javascript.ast.ScriptNode;

import ca.ubc.ece.salt.sdjsb.alert.Alert;
import ca.ubc.ece.salt.sdjsb.cfg.CFG;
import ca.ubc.ece.salt.sdjsb.cfg.CFGEdge;
import ca.ubc.ece.salt.sdjsb.cfg.CFGNode;

/**
 * Performs a change-sensitive, intra-procedural analysis.
 * 
 * This framework provides the analysis framework and the current scope.
 * 
 * Loops are executed once.
 * 
 * @param <LE> The lattice element type that stores the analysis information.
 */
public abstract class FlowAnalysis<LE extends AbstractLatticeElement> {

	/**
	 * The repair alerts generated by the analysis.
	 */
	private List<Alert> alerts;
	
	/**
	 * The control flow graphs for each function.
	 */
	private List<CFG> cfgs;

	public FlowAnalysis() { }
	
	/**
	 * Performs a flow analysis.
	 * 
	 * For JavaScript, we need to store the function-hierarchy so we can analyze
	 * them in-order and build the scope for each function.is of the script.
	 * 
	 * @param root The root AST node for the script.
	 * @param cfgs The control flow graphs for the functions (and script).
	 * @throws Exception
	 */
	public void analyze(AstRoot root, List<CFG> cfgs) throws Exception {

		Stack<Set<Name>> scopeStack = new Stack<Set<Name>>();
		this.alerts = new LinkedList<Alert>();
		this.cfgs = cfgs;
		this.analyze(root, scopeStack);
		
	}

	/**
	 * @return a list of the alerts from this analysis.
	 */
	public List<Alert> getAlerts() {
		return this.alerts;
	}
	
	/**
	 * Perform a path-sensitive analysis.
	 * 
	 * As we discover variable declarations, we add them to the scope.
	 * 
	 * @param cfg the control flow graph for the function or script we are analyzing.
	 * @param scopeStack the scope for the function.
	 */
	abstract protected void analyze(CFG cfg, Stack<Set<Name>> scopeStack);

	/**
	 * @param function The function under analysis.
	 * @return an initialized lattice element for the function.
	 */
	public abstract LE entryValue(ScriptNode function);

	/**
	 * Transfer the lattice element over the CFGEdge.
	 * @param edge The edge to transfer over.
	 */
	public abstract void transfer(CFGEdge edge, LE sourceLE);

	/**
	 * Transfer the lattice element over the CFGNode.
	 * @param node The node to transfer over.
	 */
	public abstract void transfer(CFGNode node, LE sourceLE);
	
	/**
	 * @param le The lattice element to copy.
	 * @return a deep copy of the lattice element.
	 */
	public abstract LE copy(LE le);

	/**
	 * Registers an alert to be reported to the user.
	 * @param alert
	 */
	protected void registerAlert(Alert alert) {
		this.alerts.add(alert);
	}

	/**
	 * Discovers functions and sends them to be analyzed. Keeps track of
	 * function scopes to be passed to sub-functions.
	 * @throws Exception
	 */
	private void analyze(ScriptNode function, Stack<Set<Name>> scopeStack) throws Exception {
		
        /* Create a new scope for this script or function and push it onto
         * the stack. */
        
        Set<Name> scope = new HashSet<Name>();
        scopeStack.push(scope);
        
        /* Analyze node. */
        
        CFG cfg = this.getFunctionCFG(function);
        if(cfg == null) throw new Exception("CFG not found for function.");
        this.analyze(cfg, scopeStack);
        
        /* Analyze the methods of the function. */

        //System.out.println("Function count: " + FunctionTreeVisitor.getFunctions(function)function.getFunctionCount());
        List<FunctionNode> methods = FunctionTreeVisitor.getFunctions(function);
        for(FunctionNode method : methods) {
        	analyze(method, scopeStack);
        }
        
        /* We are done with this function. Pop it's scope from the stack. */

        scopeStack.pop();

	}
	
	/**
	 * Find the CFG for the script or function.
	 * @param node a AstRoot or FunctionNode
	 * @return the CFG for the script or function.
	 */
	private CFG getFunctionCFG(ScriptNode node) {
		
		for(CFG cfg : this.cfgs) {
			if(cfg.getEntryNode().getStatement() == node) return cfg;
		}
		
		return null;
		
	}
	
}
