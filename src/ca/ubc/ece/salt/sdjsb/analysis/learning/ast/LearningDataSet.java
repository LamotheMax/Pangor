package ca.ubc.ece.salt.sdjsb.analysis.learning.ast;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.tuple.Pair;

import ca.ubc.ece.salt.sdjsb.analysis.learning.apis.KeywordDefinition;
import ca.ubc.ece.salt.sdjsb.analysis.learning.apis.KeywordUse;

/**
 * The {@code FeatureVectorManager} is a pre-processing step for data mining
 * and machine learning. {@code FeatureVectorManager} manages the feature
 * vectors that were generated during the AST analysis.
 *
 * Once all feature vectors have been built, they will contain some meta info
 * (commit {@link #clone()}, file, project, etc.) and zero or more
 * {@code Keyword}s (where a {@code Keyword} = name + context + package.
 *
 * The {@code FeatureVectorManager} filters out {@code FeatureVector}s that
 * aren't wanted (i.e., those that aren't related to a package we are
 * investigating) and features that are not used or hardly used.
 */
public class LearningDataSet {

	/**
	 * The packages we want to investigate. FeatureVectorManager
	 * filters out any FeatureVector which does not contain one of these
	 * packages.
	 */
	private List<String> packagesToExtract;

	/** An ordered list of the keywords to print in the feature vector. **/
	private Set<KeywordDefinition> keywords;

	/** The feature vectors generated by the AST analysis. **/
	private List<FeatureVector> featureVectors;

	public LearningDataSet(List<String> packagesToExtract) {
		this.packagesToExtract = packagesToExtract;
		this.keywords = new HashSet<KeywordDefinition>();
		this.featureVectors = new LinkedList<FeatureVector>();
	}

	/**
	 * Adds a feature vector.
	 * @param featureVector The feature vector to be managed by this class.
	 */
	public void registerFeatureVector(FeatureVector featureVector) {
		this.featureVectors.add(featureVector);
	}

	/**
	 * Builds the feature vector header by filtering out features (columns)
	 * that are not used or hardly used.
	 * @return The feature vector header as a CSV list.
	 */
	public String getFeatureVectorHeader() {

		String header = String.join("\t", "ID", "ProjectID", "BuggyFile",
				"RepairedFile", "BuggyCommitID", "RepairedCommitID",
				"FunctionName");

		for(KeywordDefinition keyword : this.keywords) {
			header += "\t" + keyword.toString();
		}

		return header;

	}

	/**
	 * Builds the feature vector by filtering out feature vectors (rows)
	 * that do not contain the packages specified in {@code packagesToExtract}.
	 * @return The data set as a CSV file.
	 */
	public String getFeatureVector() {

		String dataSet = "";

		for(FeatureVector featureVector : this.featureVectors) {
			dataSet += featureVector.getFeatureVector(keywords) + "\n";
		}

		return dataSet;

	}
	
	/**
	 * @return The list of feature vectors in this data set.
	 */
	public List<FeatureVector> getFeatureVectors() {
		return this.featureVectors;
	}

	/**
	 * Performs pre-processing operations for data-mining. Specifically,
	 * filters out rows which do not use the specified packages and filters
	 * out columns which do not contain any data.
	 */
	public void preProcess() {

		/* Remove rows that do not reference the packages we are interested in. */

		List<FeatureVector> toRemove = new LinkedList<FeatureVector>();
		for(FeatureVector featureVector : this.featureVectors) {

			/* Check if the feature vector references the any of the interesting packages. */
			if(!containsInterestingPackages(featureVector.keywordMap.keySet())) {

				/* Schedule this FeatureVector for removal. */
				toRemove.add(featureVector);

			}

		}

		for(FeatureVector featureVector : toRemove) {
			this.featureVectors.remove(featureVector);
		}

		/* Get the set of keywords from all the feature vectors. */

		for(FeatureVector featureVector : this.featureVectors) {
			for(KeywordDefinition keyword : featureVector.keywordMap.keySet()) keywords.add(keyword);
		}

	}

	/**
	 * @param keywords The keywords from a feature vector.
	 * @return True if the keyword set contains one or more keywords from the
	 * 		   one or more of the packages we are interested in.
	 */
	private boolean containsInterestingPackages(Set<KeywordUse> keywords) {
		for(KeywordUse keyword : keywords) {
			if (this.packagesToExtract.contains(keyword.api.getName()))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks if the feature vector manager contains the keyword inside a
	 * feature vector. Used for testing.
	 * @param function The name of the function.
	 * @param keywords The keywords to look for.
	 * @return True if the list of keywords matches the list of keywords form
	 * 		   one or more functions.
	 */
	public boolean contains(String function, List<Pair<KeywordUse, Integer>> keywords) {
		outer: 
		for(FeatureVector featureVector : this.featureVectors) {
			for(Pair<KeywordUse, Integer> keyword : keywords) {
				if(keyword.getRight() > 0 && !featureVector.keywordMap.containsKey(keyword.getLeft())) continue outer;
				if(keyword.getRight() > 0 && !featureVector.keywordMap.get(keyword.getLeft()).equals(keyword.getRight())) continue outer;
			}
			return true;
		}
		return false;
	}

}
