package ca.ubc.ece.salt.sdjsb.analysis.classify;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.LinkedList;
import java.util.List;

import ca.ubc.ece.salt.sdjsb.analysis.DataSet;
import ca.ubc.ece.salt.sdjsb.classify.alert.ClassifierAlert;

/**
 * The {@code DataSet} manages the alerts that were generated during the
 * analysis.
 */
public class ClassifierDataSet implements DataSet<ClassifierAlert> {

	/**
	 * The path to the file where the data set will be cached. This allows us
	 * to limit our memory use and cache results for the future by storing the
	 * keyword extraction results on the disk.
	 */
	private String dataSetPath;

	/**
	 * The path to the folder where any supplementary files should be stored.
	 * These files contain the function source code from the alerts.
	 */
	private String supplementaryPath;

	/** The alerts generated by the analysis. **/
	private List<ClassifierAlert> alerts;

	/**
	 * Used to produce a data set of the analysis results.
	 * @param dataSetPath The file path to store the data set.
	 * @param supplementaryPath The directory path to store the supplementary
	 * 		  files.
	 * @throws Exception Throws an exception when the {@code dataSetPath}
	 * 					 cannot be read.
	 */
	public ClassifierDataSet(String dataSetPath, String supplementaryPath) {
		this.alerts = new LinkedList<ClassifierAlert>();
		this.dataSetPath = dataSetPath;
		this.supplementaryPath = supplementaryPath;
	}

	/**
	 * Adds a alert to the data set. If a data set file exists
	 * ({@code dataSetPath}), serializes the alert and writes it to
	 * the file. Otherwise, the alert is stored in memory in
	 * {@code LearningDataSet}.
	 * @param alert The alert to be managed by this class.
	 */
	@Override
	public void registerAlert(ClassifierAlert alert) throws Exception {

		if(this.dataSetPath != null) {
			this.storeAlert(alert);
		}
		else {
			this.alerts.add(alert);
		}

	}

	/**
	 * Stores the alert in the file specified by {@code dataSetPath}.
	 * This method is synchronized because it may be used by several
	 * GitProjectAnalysis thread at the same time, which may cause race
	 * conditions when writing to the output file.
	 *
	 * @param alert The alert to be managed by this class.
	 */
	private synchronized void storeAlert(ClassifierAlert alert) throws Exception {

		/* The path to the file may not exist. Create it if needed. */
		File path = new File(this.dataSetPath);
		path.getParentFile().mkdirs();
		path.createNewFile();

		/* May throw IOException if the path does not exist. */
		PrintStream stream = new PrintStream(new FileOutputStream(path, true));

		/* Write the data set. */
		stream.println(alert.serialize());

		/* Finished writing the alert. */
		stream.close();

		/* Write the source code to a folder so we can examine it later. */
		this.printSupplementaryFiles(alert);

	}

	/**
	 * Builds the alert header by filtering out features (columns)
	 * that are not used or hardly used.
	 * @return The alert header as a CSV list.
	 */
	public String getalertHeader() {

		String header = String.join(",", "ID", "ProjectID", "ProjectHomepage", "BuggyFile",
				"RepairedFile", "BuggyCommitID", "RepairedCommitID",
				"FunctionName");

		return header;

	}

	/**
	 * Builds the alert by filtering out alerts (rows)
	 * that do not contain the packages specified in {@code packagesToExtract}.
	 * @return The data set as a CSV file.
	 */
	public String getalert() {

		String dataSet = "";

		return dataSet;

	}

	/**
	 * @return The list of alerts in this data set.
	 */
	public List<ClassifierAlert> getAlerts() {
		return this.alerts;
	}

	/**
	 * Writes the source code from each of the inspected functions to a file.
	 * @param supplementaryFolder The folder to place the files in.
	 */
	private void printSupplementaryFiles(ClassifierAlert alert) {

		/* The path to the supplementary folder may not exist. Create
		 * it if needed. */
		File path = new File(this.supplementaryPath);
		path.mkdirs();

		File src = new File(this.supplementaryPath, alert.id + "_src.js");
		File dst = new File(this.supplementaryPath, alert.id + "_dst.js");

		try (PrintStream srcStream = new PrintStream(new FileOutputStream(src));
			 PrintStream dstStream = new PrintStream(new FileOutputStream(dst));) {

			srcStream.print(alert.ami.buggyCode);
			dstStream.print(alert.ami.repairedCode);

			srcStream.close();
			dstStream.close();

		} catch (FileNotFoundException e) {
			System.err.println(e.getMessage());
		}

	}

}
