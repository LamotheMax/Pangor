require "csv"

INPUT_FILE = "../output/remote_all_checkers/output7_ttt/dataset.csv"
SUPPLEMENTARY_FOLDER = '../output/remote_all_checkers/output7_ttt/supplementary/'

class Alert
  attr_accessor :id, :project, :function_name, :type, :subtype, 
    :short_description, :long_description, :inspection_result,
    :original_row

  attr_accessor :github_url, :fix_commit

  def initialize(row)
    @original_row = row

    @id = row[0]
    @project = row[1]
    @function_name = row[7]
    @type = row[8]
    @subtype = row[9]
    @short_description = row[10]
    @long_description = row[11]

    @github_url = row[2]
    @fix_commit = row[6]

    # Check if the file we are reading has already inspection results
    if (%w{y n ?}.include?(row[12]))
      @inspection_result = row[12]
    else
      @inspection_result = ""
    end
  end

  def to_s
    "ID: #{@id} \nPROJECT: #{@project} \nTYPE: #{@type} \nSUBTYPE: #{@subtype}" + 
      "\nFUNCTION: #{@function_name} \nSHORT: #{@short_description} \nLONG: #{long_description} \n\n== INSPECTION_RESULT: #{inspection_result}"
  end

  def to_array
    if (@original_row.size == 12)
      # We are inspecting dataset.csv from classifier, 
      # which does not have yet a column for inspection results, so we create it

      return @original_row << @inspection_result  
    else
      # We are inspecting a file generated by this script,
      # which has a column for inspection results, so we update it

      @original_row[-1] = @inspection_result
      return @original_row
    end
    
  end
end

class GuiDiffViewer
  TOOL = 'meld'

  def self.open(alert)
    src = File.join(SUPPLEMENTARY_FOLDER, "#{alert.id}_src.js")
    dst = File.join(SUPPLEMENTARY_FOLDER, "#{alert.id}_dst.js")

    return Process.spawn("#{TOOL} #{src} #{dst}")
  end

  def self.kill(pid)
    Process.kill('TERM', pid)
  end
end

class BrowserDiffViewer
  TOOL = 'firefox'

  def self.open(alert)
    url = "#{alert.github_url}/commit/#{alert.fix_commit}"

    return Process.spawn("#{TOOL} #{url} 2>&1 > /dev/null")
  end

  def self.kill(pid)
    # Process.kill('TERM', pid)
  end
end

class ResultsPrinter
  def self.print(alerts)
    inspected = alerts.select{|a| ! a.inspection_result.empty? }.size
    tp = alerts.select{|a| a.inspection_result == "y"}.size
    fp = alerts.select{|a| a.inspection_result == "n"}.size

    puts "=== RESULTS ==="
    puts "== INSPECTED: #{inspected}"
    puts "=== TRUE: #{tp}"
    puts "=== FALSE: #{fp}"
    puts "== PRECISION: #{tp.to_f/inspected}"
  end
end


# Parse csv file
alerts = []

skip_to_next_empty = false

current_row = 1
total_rows = File.open(INPUT_FILE).count


# First we create array with all alerts
CSV.foreach(INPUT_FILE) do |row|
  alert = Alert.new(row)
  alerts << alert
end

# Shuffle the alerts and sort by inspection results
alerts = alerts.shuffle.sort_by{|a| a.inspection_result}.reverse

# Then we start the inspection
for alert in alerts 
  # If we are looking for next empty
  if skip_to_next_empty

    # If this alert is empty, stop it here
    if (alert.inspection_result.nil? || alert.inspection_result.empty?)
      skip_to_next_empty = false
    else
      current_row += 1
      next
    end
  end

  puts "=" * 50

  # Print results
  ResultsPrinter.print(alerts)

  # Open diff
  #pid = BrowserDiffViewer.open(alert)
  pid1 = GuiDiffViewer.open(alert)
  pid2 = BrowserDiffViewer.open(alert)

  # Read input
  puts "\n=== Alert inspection (#{current_row} / #{total_rows}) ==="
  puts alert
  puts "\n(y) for YES, (n) for NO, (?) to MARK"
  puts "(s) or (anything) to SKIP to next alert"
  puts "(ss) to SKIP-SKIP to next inespected alert"
  puts "(q) for QUIT"
  input = gets.chomp

  # Close diff
  # BrowserDiffViewer.kill(pid)
  GuiDiffViewer.kill(pid1)
  BrowserDiffViewer.kill(pid2)

  # Parse input
  case input
  when 'y', 'n', '?'
    alert.inspection_result = input
  when 'q'
    break
  when 'ss'
    skip_to_next_empty = true
    next
  end 
  
  # Increment counter, just to show to user
  current_row += 1
end

puts "==> Saving file"

# Save alerts to file
CSV.open(INPUT_FILE, "w") do |csv|
  alerts = alerts.sort_by{|a| a.inspection_result}.reverse

  for alert in alerts
    csv << alert.to_array
  end
end
